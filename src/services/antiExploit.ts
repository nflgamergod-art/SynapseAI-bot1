import { getDB } from './db';
import { Client, TextChannel, EmbedBuilder } from 'discord.js';

/**
 * Anti-Exploit System
 * Prevents staff from exploiting the system to get paid without being scheduled
 * Tracks violations and issues penalties
 */

export function initAntiExploitSchema() {
  const db = getDB();
  db.exec(`
    CREATE TABLE IF NOT EXISTS exploit_violations (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      guild_id TEXT NOT NULL,
      user_id TEXT NOT NULL,
      violation_type TEXT NOT NULL,  -- 'unscheduled_clockin', 'unscheduled_ticket_claim', 'unscheduled_message'
      description TEXT NOT NULL,
      severity TEXT NOT NULL DEFAULT 'minor',  -- 'minor', 'moderate', 'severe'
      penalty_applied TEXT,  -- Description of penalty
      detected_at TEXT NOT NULL,
      reviewed BOOLEAN NOT NULL DEFAULT 0,
      reviewed_by TEXT,
      reviewed_at TEXT
    );
    
    CREATE TABLE IF NOT EXISTS exploit_penalties (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      guild_id TEXT NOT NULL,
      user_id TEXT NOT NULL,
      penalty_type TEXT NOT NULL,  -- 'warning', 'upt_deduction', 'pay_reduction', 'suspension'
      amount REAL,  -- For deductions/reductions
      reason TEXT NOT NULL,
      issued_by TEXT NOT NULL,  -- 'system' or user_id
      issued_at TEXT NOT NULL,
      active BOOLEAN NOT NULL DEFAULT 1
    );
    
    CREATE INDEX IF NOT EXISTS idx_exploit_violations_guild_user ON exploit_violations(guild_id, user_id);
    CREATE INDEX IF NOT EXISTS idx_exploit_penalties_guild_user ON exploit_penalties(guild_id, user_id);
  `);
}

interface ExploitCheck {
  allowed: boolean;
  reason?: string;
  requiresApproval?: boolean;
}

// Check if staff can work right now (scheduled or has approval)
export function canStaffWorkNow(guildId: string, userId: string): ExploitCheck {
  const { isScheduledToday, hasApprovedWorkRequestToday } = require('./scheduling');
  
  const scheduled = isScheduledToday(guildId, userId);
  const hasApproval = hasApprovedWorkRequestToday(guildId, userId);
  
  if (scheduled || hasApproval) {
    return { allowed: true };
  }
  
  return {
    allowed: false,
    reason: 'You are not scheduled to work today. You must request permission from the owner first.',
    requiresApproval: true
  };
}

// Log an exploit violation
export function logExploitViolation(
  guildId: string,
  userId: string,
  violationType: string,
  description: string,
  severity: 'minor' | 'moderate' | 'severe' = 'minor'
): number {
  const db = getDB();
  const now = new Date().toISOString();
  
  const result = db.prepare(`
    INSERT INTO exploit_violations 
    (guild_id, user_id, violation_type, description, severity, detected_at)
    VALUES (?, ?, ?, ?, ?, ?)
  `).run(guildId, userId, violationType, description, severity, now);
  
  const violationId = result.lastInsertRowid as number;
  
  // Auto-apply penalties based on severity and repeat offenses
  const recentViolations = getRecentViolations(guildId, userId, 30); // Last 30 days
  
  if (recentViolations.length >= 3) {
    // 3+ violations in 30 days = severe penalty
    applyPenalty(guildId, userId, 'upt_deduction', 480, 'Repeated system exploitation attempts', 'system');
    applyPenalty(guildId, userId, 'warning', null, 'Final warning: further violations may result in suspension', 'system');
    
    db.prepare(`
      UPDATE exploit_violations SET penalty_applied = ? WHERE id = ?
    `).run('480 minutes UPT deduction + final warning', violationId);
  } else if (recentViolations.length === 2) {
    // 2nd violation = moderate penalty
    applyPenalty(guildId, userId, 'upt_deduction', 240, 'Second system exploitation attempt', 'system');
    
    db.prepare(`
      UPDATE exploit_violations SET penalty_applied = ? WHERE id = ?
    `).run('240 minutes UPT deduction', violationId);
  } else {
    // 1st violation = warning
    applyPenalty(guildId, userId, 'warning', null, 'First system exploitation attempt - do not try to work when not scheduled', 'system');
    
    db.prepare(`
      UPDATE exploit_violations SET penalty_applied = ? WHERE id = ?
    `).run('Warning issued', violationId);
  }
  
  return violationId;
}

// Apply a penalty to a user
export function applyPenalty(
  guildId: string,
  userId: string,
  penaltyType: string,
  amount: number | null,
  reason: string,
  issuedBy: string
): number {
  const db = getDB();
  const now = new Date().toISOString();
  
  const result = db.prepare(`
    INSERT INTO exploit_penalties 
    (guild_id, user_id, penalty_type, amount, reason, issued_by, issued_at)
    VALUES (?, ?, ?, ?, ?, ?, ?)
  `).run(guildId, userId, penaltyType, amount, reason, issuedBy, now);
  
  // Execute the penalty
  if (penaltyType === 'upt_deduction' && amount) {
    try {
      const { deductUPT } = require('./scheduling');
      deductUPT(guildId, userId, amount, reason);
    } catch (err) {
      console.error('Failed to deduct UPT:', err);
    }
  }
  
  if (penaltyType === 'pay_reduction' && amount) {
    // Apply pay reduction multiplier
    try {
      const { setPayrollAdjustment } = require('./payroll');
      setPayrollAdjustment(guildId, userId, 1 - amount, reason);
    } catch (err) {
      console.error('Failed to apply pay reduction:', err);
    }
  }
  
  return result.lastInsertRowid as number;
}

// Get recent violations for a user
export function getRecentViolations(guildId: string, userId: string, days: number): any[] {
  const db = getDB();
  const since = new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString();
  
  return db.prepare(`
    SELECT * FROM exploit_violations
    WHERE guild_id = ? AND user_id = ? AND detected_at > ?
    ORDER BY detected_at DESC
  `).all(guildId, userId, since) as any[];
}

// Get all violations for review
export function getUnreviewedViolations(guildId: string): any[] {
  const db = getDB();
  
  return db.prepare(`
    SELECT * FROM exploit_violations
    WHERE guild_id = ? AND reviewed = 0
    ORDER BY detected_at DESC
  `).all(guildId) as any[];
}

// Mark violation as reviewed
export function markViolationReviewed(violationId: number, reviewedBy: string) {
  const db = getDB();
  const now = new Date().toISOString();
  
  db.prepare(`
    UPDATE exploit_violations
    SET reviewed = 1, reviewed_by = ?, reviewed_at = ?
    WHERE id = ?
  `).run(reviewedBy, now, violationId);
}

// Get active penalties for a user
export function getActivePenalties(guildId: string, userId: string): any[] {
  const db = getDB();
  
  return db.prepare(`
    SELECT * FROM exploit_penalties
    WHERE guild_id = ? AND user_id = ? AND active = 1
    ORDER BY issued_at DESC
  `).all(guildId, userId) as any[];
}

// Deactivate a penalty
export function deactivatePenalty(penaltyId: number) {
  const db = getDB();
  
  db.prepare(`
    UPDATE exploit_penalties SET active = 0 WHERE id = ?
  `).run(penaltyId);
}

// Get violation stats for a user
export function getUserViolationStats(guildId: string, userId: string): {
  totalViolations: number;
  last30Days: number;
  activePenalties: number;
  totalUptDeducted: number;
} {
  const db = getDB();
  
  const total = db.prepare(`
    SELECT COUNT(*) as count FROM exploit_violations
    WHERE guild_id = ? AND user_id = ?
  `).get(guildId, userId) as { count: number };
  
  const recent = getRecentViolations(guildId, userId, 30);
  
  const activePenalties = db.prepare(`
    SELECT COUNT(*) as count FROM exploit_penalties
    WHERE guild_id = ? AND user_id = ? AND active = 1
  `).get(guildId, userId) as { count: number };
  
  const uptDeducted = db.prepare(`
    SELECT SUM(amount) as total FROM exploit_penalties
    WHERE guild_id = ? AND user_id = ? AND penalty_type = 'upt_deduction'
  `).get(guildId, userId) as { total: number | null };
  
  return {
    totalViolations: total.count,
    last30Days: recent.length,
    activePenalties: activePenalties.count,
    totalUptDeducted: uptDeducted.total || 0
  };
}

// Send notification to owner about violation
export async function notifyOwnerOfViolation(
  client: Client,
  guildId: string,
  userId: string,
  violation: any,
  ownerId: string
) {
  try {
    const user = await client.users.fetch(userId);
    const owner = await client.users.fetch(ownerId);
    
    const embed = new EmbedBuilder()
      .setTitle('‚ö†Ô∏è System Exploit Detected')
      .setDescription(`<@${userId}> attempted to work while not scheduled.`)
      .setColor(0xFF0000)
      .addFields(
        { name: 'User', value: `${user.tag} (<@${userId}>)`, inline: true },
        { name: 'Violation Type', value: violation.violation_type, inline: true },
        { name: 'Severity', value: violation.severity, inline: true },
        { name: 'Description', value: violation.description },
        { name: 'Penalty Applied', value: violation.penalty_applied || 'None', inline: true },
        { name: 'Time', value: `<t:${Math.floor(new Date(violation.detected_at).getTime() / 1000)}:F>`, inline: true }
      )
      .setTimestamp();
    
    const stats = getUserViolationStats(guildId, userId);
    if (stats.totalViolations > 1) {
      embed.addFields({
        name: 'üìä Violation History',
        value: `Total: ${stats.totalViolations} | Last 30 days: ${stats.last30Days} | Active penalties: ${stats.activePenalties}`
      });
    }
    
    await owner.send({ embeds: [embed] });
  } catch (err) {
    console.error('Failed to notify owner of violation:', err);
  }
}

// Get violation report for display
export function getViolationReport(guildId: string, days: number = 30): {
  totalViolations: number;
  byType: Record<string, number>;
  bySeverity: Record<string, number>;
  topOffenders: { userId: string; count: number }[];
} {
  const db = getDB();
  const since = new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString();
  
  const violations = db.prepare(`
    SELECT * FROM exploit_violations
    WHERE guild_id = ? AND detected_at > ?
  `).all(guildId, since) as any[];
  
  const byType: Record<string, number> = {};
  const bySeverity: Record<string, number> = {};
  const userCounts: Record<string, number> = {};
  
  for (const v of violations) {
    byType[v.violation_type] = (byType[v.violation_type] || 0) + 1;
    bySeverity[v.severity] = (bySeverity[v.severity] || 0) + 1;
    userCounts[v.user_id] = (userCounts[v.user_id] || 0) + 1;
  }
  
  const topOffenders = Object.entries(userCounts)
    .map(([userId, count]) => ({ userId, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 10);
  
  return {
    totalViolations: violations.length,
    byType,
    bySeverity,
    topOffenders
  };
}

// Remove unauthorized shift time from a user
export function removeUnauthorizedShiftTime(
  guildId: string,
  userId: string,
  shiftId: number,
  reason: string,
  removedBy: string
): { success: boolean; message: string; minutesRemoved?: number } {
  const db = getDB();
  
  // Get the shift
  const shift = db.prepare(`
    SELECT * FROM shifts WHERE id = ? AND guild_id = ? AND user_id = ?
  `).get(shiftId, guildId, userId) as any;
  
  if (!shift) {
    return { success: false, message: 'Shift not found' };
  }
  
  if (!shift.clock_out) {
    return { success: false, message: 'Cannot remove time from an active shift. Please force clock-out first.' };
  }
  
  const minutesRemoved = shift.duration_minutes || 0;
  
  // Delete the shift
  db.prepare(`DELETE FROM shifts WHERE id = ?`).run(shiftId);
  
  // Log the removal
  db.prepare(`
    INSERT INTO exploit_violations 
    (guild_id, user_id, violation_type, description, severity, detected_at, reviewed, reviewed_by)
    VALUES (?, ?, 'unauthorized_shift_removal', ?, 'severe', ?, 1, ?)
  `).run(
    guildId,
    userId,
    `${minutesRemoved} minutes of unauthorized shift time removed. Reason: ${reason}`,
    new Date().toISOString(),
    removedBy
  );
  
  // Apply UPT penalty
  try {
    const { deductUPT } = require('./scheduling');
    deductUPT(guildId, userId, 240, 'Penalty for unauthorized shift time');
  } catch (err) {
    console.error('Failed to deduct UPT:', err);
  }
  
  return {
    success: true,
    message: `Removed ${minutesRemoved} minutes of unauthorized shift time from shift #${shiftId}`,
    minutesRemoved
  };
}

// Find potentially unauthorized shifts (worked when not scheduled)
export function findUnauthorizedShifts(guildId: string, userId: string, days: number = 30): any[] {
  const { isScheduledForDate } = require('./scheduling');
  const db = getDB();
  const since = new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString();
  
  const shifts = db.prepare(`
    SELECT * FROM shifts
    WHERE guild_id = ? AND user_id = ? AND clock_in > ?
    ORDER BY clock_in DESC
  `).all(guildId, userId, since) as any[];
  
  const unauthorized: any[] = [];
  
  for (const shift of shifts) {
    const shiftDate = new Date(shift.clock_in);
    const scheduled = isScheduledForDate(guildId, userId, shiftDate);
    
    if (!scheduled) {
      unauthorized.push({
        ...shift,
        reason: 'Not scheduled for this date'
      });
    }
  }
  
  return unauthorized;
}
